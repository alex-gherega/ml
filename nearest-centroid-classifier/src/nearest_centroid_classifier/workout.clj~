(ns nearest-centroid-classifier.core
  ;; TODO: prepare for workshop; remove the require bellow
  (:require [clojure.data.csv :as csv]
            [clojure.java.io :as io]))

(def test-data [5.1,3.5,1.4,0.2]) ;; it is setosa

; ..................................... DATA PROCESSING

;; FIXME:.............................................
;; TODO: remove bellow and leave as what's commented in

(defn read-raw [...args]
  ;; this function should receive a single argument; a string denoting a valid path to a csv file;
  ;; it will use clojure.data.csv API to read the csv file into a Clojure data structure - a lazy sequence of vectors
  ;; return the above content as a vector of vectors
  ....fn body)

(defn parse-elem [elem]
  (if (string? elem) elem (read-string elem)))

(defn parse-line [...args]
  ;; this fn will receive a single line denoting a csv line - i.e. a Clojure vector with strings;
  ;; the argument is a vector; make sure to preserve it
  ;; make sure strings remain string; use the pare-elem fn from above
  ;; the output should be a vector with Clojure data in it (i.e. "3" -> 3)
  ....fn body
  )

(defn process-line [...args]
  ;; this function receives as arguments:
  ;;     * an id-value which is a positive integer (0,1,2....)
  ;;     * data - the output from parse-line above 
  ;; it will output a map: {:id id-value :data data}
  ....fn body)

(defn process [...args]
  ;; we use this function to mainly walk a raw csv input
  ;; input argument is a vector of vectors; each vector is a csv line - a vector of strings
  ;; output should be an enriched vector of Clojure datastructures depicting a csv line; we use the above process-line for this
  ....fn body)

(def input-data (process (take-last 120 (read-raw "resources/iris.csv"))))
;; should output something like:
;;
;; [{:id 0, :data [4.8 3.1 1.6 0.2 "setosa"]} {:id 1, :data [5.4 3.4 1.5 0.4 "setosa"]} {:id 2, :data [5.2 4.1 1.5 0.1 "setosa"]} .....]





;; ............................................ ALGORITHM

;; Training procedure: given labeled training samples {(xv1,y1) ... (xvn,yn)}
;; computed the per-class centroids miu-l =  1/|Cl| SUM xvi for i in Cl; Cl is the set of indices of samples belonging to class l ∈ Y

;; Prediction function: the class assigned to an observation xv is
;; y = arg min || miu-l - xv || for l ∈ Y

(defn sum-vectors [v1 v2 & vecs]
  (vec (apply map + v1 v2 vecs)))

(defn subb-vectors [v1 v2]
  (vec (map - v1 v2)))
(defn class-pred [x class-name]
  (-> x :data last (= class-name)))

(defn filter-class [data class-name]
  (vec (filter (fn [x] (class-pred x class-name)) data)))

;; TODO: extract classes from csv; for now we'll hardcode them:
(def setosa-class "setosa")
(def versi-class "versicolor")
(def virginica-class "virginica")

(defn build-class-idx [filtered-data]
  (vec (map :id filtered-data)))

(def cl-setosa (build-class-idx (filter-class input-data setosa-class)))
(def cl-versi (build-class-idx (filter-class input-data versi-class)))
(def cl-virginica (build-class-idx (filter-class input-data virginica-class)))

(defn compute-centroid [data class-name]
  (let [filtered-class (filter-class data class-name)
        class-vectors (vec (map #(-> % :data butlast vec)
                                filtered-class))
        class-idx (build-class-idx filtered-class)
        norm (count class-idx)]
    ;; compute miu
    (conj (vec (map #(/ % norm) (apply sum-vectors class-vectors))) class-name)))

(def miu-setosa (compute-centroid input-data setosa-class))
(def miu-versi (compute-centroid input-data versi-class))
(def miu-virginica (compute-centroid input-data virginica-class))

(def mius (vec (map #(compute-centroid input-data %) [setosa-class versi-class virginica-class])))

; ....................... PREDICT
;; use euclidean norm
(defn compute-distance [miu input]
  (let [miu-vector (butlast miu)
        miu-class (last miu)]
    [(reduce + (map #(* % %) (subb-vectors miu input))) miu-class]))


(defn arg-min [distances]
  (reduce (fn [[d1 c1] [d2 c2]]
            (if (<= d1 d2)
              [d1 c1]
              [d2 c2]))
          distances))

(defn predict [input mius]
  (arg-min (map #(compute-distance % input) mius)))

(defn test [] (predict test-data mius))
